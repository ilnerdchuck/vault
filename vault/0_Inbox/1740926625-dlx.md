---
id: 1740926625-dlx
aliases:
  - DLX
tags: []
title: DLX
---
32 bit addressable memory
# DLX register 
  - General purpose register (GPR)
  - Floating point register (FPR)

# DLX data type 
  - Integer 
      - 32 bit word
      - 16 bit half word
      - 8  bit byte
  - Floating point types

# DLX memory
  - Byte addressable in Big-Endian mode with 32 bit address

# DLX instructions 
  - I-Type: immediate to register operation (LOAD/STORE, immeddiate, jump with reg)
  - R-Type: Register to register operation (ALU operation) 
  - J-Type: jump operation (ALU for new PC)

# DLX Pipeline architecture
 ![DLX_Pipeline.png](assets/imgs/DLX_Pipeline.png)
 ## DLX Operations
 - Instruction Fetch (IF):
     - IR <- MEM\[PC\]
     - NPC <- PC + 4
 - Instruction Decode (ID):
     - A <- REGS\[R₆...R₁₀\] 
     - B <- REGS\[R₁₁...R₁₅\]
     - Imm <- ((IR₁₆)¹⁶ ## IR₁₆...IR₃₁) what is this notation?: POW is replication(repeat the number) and ## is concatenation
         - replicate the MSB of the instruction and then concatenate with the Upper half of the IR
         ![IR_concat_replic.png](assets/imgs/IR_concat_replic.png)
 - Execution: 
     - Register-Register ALU: ALUOUT <- A OPCODE B
     - Register-Immediate ALU: ALUOUT <- A OPCODE Imm
     - Memory Reference ALU: ALUOUT <- A + Imm
     - Branch:
         - ALUOUT <- NPC + Imm
         - COND <- A op(== or !=) '0'
 - Write-Back(WB)
     - Register-Register <- ALU: REGS\[R₁₆...R₂₀\] <- ALUOUT
     - Register-Immediate <- ALU: REGS\[R₁₁...R₁₅\] <- ALUOUT
     - Load Instruction <- LMD (Load Memory Data): REGS\[R₁₁...R₁₅\] <- LMD
 - Memory Access/Branch Completion 
     - Program Counter updated (PC): PC <- NewPC (NPC)
     - Memory Reference:  
        - Load: LMD <- MEM\[ALUOUT\]
        - Store: MEM\[ALUOUT\] <- B
     - Branch: if (cond == true) PC <- ALUOUT

